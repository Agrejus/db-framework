import { IDbRecord } from "../types/entity-types";
import { groupBy } from "../common/helpers";
import { IValidationResult, IDbPlugin, IQueryParams, IBulkOperationsResponse, DbPluginOperations } from "../types/plugin-types";
import { Transactions } from "../common/Transactions";
import { IDictionary, DeepPartial } from "../types/common-types";

export abstract class DbPlugin<TDocumentType extends string, TEntityBase extends IDbRecord<TDocumentType>, TExclusions extends keyof TEntityBase = never> implements IDbPlugin<TDocumentType, TEntityBase, TExclusions> {
    
    readonly abstract identifier: keyof TEntityBase;
    readonly abstract idPropertyName: keyof TEntityBase;
    readonly abstract types: { exclusions: TExclusions }
    abstract destroy(): Promise<void>;
    abstract all(payload?: IQueryParams<TDocumentType, TEntityBase>): Promise<TEntityBase[]>;
    abstract get(DocumentType: TDocumentType, ...ids: string[]): Promise<TEntityBase[]>;
    abstract bulkOperations(operations: { adds: TEntityBase[], removes: TEntityBase[], updates: { data: TEntityBase[], deltas: IDictionary<DeepPartial<TEntityBase>>; } }, transactions: Transactions): Promise<IBulkOperationsResponse>;
    readonly abstract skip: (keyof TEntityBase )[]
    
    /**
     * Takes in the reponse from saving to the database, the entities that were acted on and should set any DB generated values.  NOTE:  Ids should not be auto generated by the database, if they are, we cannot correctly identify an entity, because it has no identifying information for DB Framework to use.  If we cannot identify an entity, then we cannot set DB generated values.
     * 
     * Example:  For PouchDB, entities that are saved to the database, this function is used to set the DB generated _rev value.
     * @param response 
     * @param entity 
     */
    abstract enrichGenerated(response: IBulkOperationsResponse, entity: TEntityBase): TEntityBase;

    async getStrict(_: TDocumentType, ...ids: string[]): Promise<TEntityBase[]> {
        const result = await this.get(_, ...ids);

        if (result.length != ids.length) {
            throw new Error('Could not find one or more documents')
        }

        return result;
    }

    validateEntity(entity: TEntityBase) {
        const properties: (keyof TEntityBase)[] = [this.idPropertyName, this.identifier, "DocumentType"];

        return properties.map(w => {
            const value = entity[w];
            const result: IValidationResult<TDocumentType, TEntityBase> = {
                ok: true,
                propertyName: w,
                error: "",
                entity
            };
    
            if (value == null) {
                result.ok = false;
                result.error = `Property cannot be null or undefined.  Property: ${String(w)}, Entity: ${JSON.stringify(entity)}`
                return result;
            }
    
            return result;
        })
    }

    /**
     * Prepares entities to be attached to the Db Set.  Used when .link() is called on a Db Set.  This method is responsible for finding the existing entity and merging it with the entity passed into this function.  Should set any properties and return the result of the merge
     * If there are no properties to be set, then override and return `{ ok: true, docs: [], errors: [] }`
     * 
     * Example:  For PouchDB, we try and find existing documents by _id, then we use only the _rev property from the found document, and set it on the entity from the parameters.  This function also verifies that the _rev, DocumentType, and _id properties are set.  We look up the entity, because we want to ensure the entity being passed in has the latest _rev so it is saved properly
     * @param entities 
     * @returns 
     */
    async prepareAttachments(...entities: TEntityBase[]) {
        const validationFailures = entities.map(w => this.validateEntity(w)).flat().filter(w => w.ok === false);
        const result: { ok: boolean, docs: TEntityBase[], errors: string[] } = {
            ok: true,
            docs: [],
            errors: []
        }
        if (validationFailures.length > 0) {
            result.errors = validationFailures.map(w => w.error);
            result.ok = false;
            return result;
        }

        const entityMap = groupBy(entities, "DocumentType");
        const foundAll = await Promise.all(Object.keys(entityMap).map(w => this.getStrict(w as TDocumentType, ...entityMap[w as keyof TEntityBase].map(w => w[this.idPropertyName] as string))));
        
        const found = foundAll.reduce((a, v) => a.concat(v), []);

        const foundDictionary = found.reduce((a, v) => ({ ...a, [v[this.idPropertyName] as string]: v[this.identifier] }), {} as { [key: string]: unknown });
        
        result.docs = entities.map(w => ({ ...w, [this.identifier]: foundDictionary[w[this.idPropertyName] as string] } as TEntityBase));

        return result;
    }

    /**
     * Formats entites to be detached from the Db Set.  This function is called by .unlink()
     * 
     * Example:  For PouchDB, entities that can be detached must have an _id, _rev, and DocumentType set.  If they are missing these properties, we cannot detach properly and should return errors.
     * @param entities 
     * @returns 
     */
    prepareDetachments(...entities: TEntityBase[]): { ok: boolean; errors: string[]; docs: TEntityBase[]; } {
        const validationFailures = entities.map(w => this.validateEntity(w)).flat().filter(w => w.ok === false);
        const result: { ok: boolean, docs: TEntityBase[], errors: string[] } = {
            ok: true,
            docs: [],
            errors: []
        }

        if (validationFailures.length > 0) {
            result.errors = validationFailures.map(w => w.error);
            result.ok = false;
            return result;
        }

        result.docs = entities;
        return result;
    }

    /**
     * Some databases only do soft deletes and work by setting an flag like _deleted to deleted items.  If this is not the case, we can just return the passed in entites.  Otherise format entites as needed so they can be deleted properly.
     * 
     * Example:  For PouchDB, this function maps entites to remove all properties but _id, _rev, and adds the _deleted flag
     * @param entity 
     * @returns 
     */
    enrichRemoval(entity: TEntityBase) {
        return { ...entity } as TEntityBase
    }

    isOperationAllowed(entity: TEntityBase, operation: DbPluginOperations) {

        const map = {
            "add": this.isAdditionAllowed.bind(this),
            "remove": this.isRemovalAllowed.bind(this)
        }

        const cb = map[operation]

        if (cb == null) {
            return { ok: true }
        }

        return cb(entity);
    }

    /**
     * Checks to see if an entity is added to the database.  Identifer should be a property that is generated by the database or generated on save like an id or revision number.
     * If this does not matter, override this method and return `{ ok: true }`
     * @param entity 
     * @param identifier 
     */
    protected isAdditionAllowed(entity: TEntityBase) {
        const indexableEntity = entity as any;

        // cannot add an entity that already has a rev, means its in the database already
        if (!!indexableEntity[this.identifier]) {
            return {
                ok: false,
                error: "Cannot add entity that is already in the database, please modify entites by reference or attach an existing entity"
            }
        }

        return { ok: true };
    }

    /**
     * Checks to see if an entity is removed from the database.  Identifer should be a property that is generated by the database or generated on save like an id or revision number.
     * If the property exists, then we know the entity was saved to the database.  If this does not matter, override this method and return `{ ok: true }`
     * @param entity 
     * @param identifier 
     */
    protected isRemovalAllowed(entity: TEntityBase) {
        const indexableEntity = entity as any;

        // cannot add an entity that already has a rev, means its in the database already
        if (!indexableEntity[this.identifier]) {
            return {
                ok: false,
                error: `Cannot remove entity that is not in the database, please supply ${String(this.identifier)} property`
            }
        }

        return { ok: true };
    }
}